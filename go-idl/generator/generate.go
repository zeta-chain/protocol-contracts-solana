package main

import (
	"fmt"
	"strings"

	"github.com/zeta-chain/protocol-contracts-solana/go-idl/types"
)

const (
	codeGenerationDisclaimer = `// Code generated by go-idl. DO NOT EDIT.`
	idlPrefix                = "IDL"
	instructionNamePrefix    = "Instruction"
)

// generateIDLFile generates the Go code for the IDL struct.
func generateIDLFile(packagename, varname string, idl *types.IDL) string {
	var sb strings.Builder

	// header
	sb.WriteString(fmt.Sprintf("%s\n", codeGenerationDisclaimer))
	sb.WriteString(fmt.Sprintf("package %s\n\n", packagename))
	sb.WriteString("import (\n")
	sb.WriteString("    \"github.com/zeta-chain/protocol-contracts-solana/go-idl/types\"\n")
	sb.WriteString(")\n\n")

	// IDL struct
	sb.WriteString(fmt.Sprintf("var %s%s = ", idlPrefix, varname))
	sb.WriteString(generateIDLTypeCode(idl))
	sb.WriteString(generateInstructionNames(idl))

	return sb.String()
}

// generateIDLTypeCode generates Go code to initialize the IDL struct.
func generateIDLTypeCode(idl *types.IDL) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("types.IDL{\n"))
	sb.WriteString(fmt.Sprintf("    Address: %q,\n", idl.Address))
	sb.WriteString(fmt.Sprintf("    Metadata: types.Metadata{\n"))
	sb.WriteString(fmt.Sprintf("        Name: %q,\n", idl.Metadata.Name))
	sb.WriteString(fmt.Sprintf("        Version: %q,\n", idl.Metadata.Version))
	sb.WriteString(fmt.Sprintf("        Spec: %q,\n", idl.Metadata.Spec))
	sb.WriteString(fmt.Sprintf("        Description: %q,\n", idl.Metadata.Description))
	sb.WriteString("    },\n")

	// write instructions
	sb.WriteString("    Instructions: []types.Instruction{\n")
	for _, instr := range idl.Instructions {
		sb.WriteString("        {\n")
		sb.WriteString(fmt.Sprintf("            Name: %q,\n", instr.Name))
		sb.WriteString(fmt.Sprintf("            Discriminator: %v,\n", generateDiscriminatorCode(
			instr.Discriminator,
		)))
		sb.WriteString("            Accounts: []types.Account{\n")
		for _, acc := range instr.Accounts {
			sb.WriteString(generateAccountCode(acc))
		}
		sb.WriteString("            },\n")

		// TODO: args generation
		//sb.WriteString("            Args: []types.Arg{\n")
		//for _, arg := range instr.Args {
		//	sb.WriteString(fmt.Sprintf("                {Name: %q, Type: %v},\n", arg.Name, arg.Type))
		//}
		//sb.WriteString("            },\n")

		sb.WriteString("        },\n")
	}
	sb.WriteString("    },\n")

	// write accounts
	sb.WriteString("    Accounts: []types.Account{\n")
	for _, acc := range idl.Accounts {
		sb.WriteString(generateAccountCode(acc))
	}
	sb.WriteString("    },\n")

	// write errors
	sb.WriteString("    Errors: []types.Error{\n")
	for _, err := range idl.Errors {
		sb.WriteString(fmt.Sprintf("        {Code: %d, Name: %q, Msg: %q},\n", err.Code, err.Name, err.Msg))
	}
	sb.WriteString("    },\n")

	// write types
	// TODO: types generation
	//sb.WriteString("    Types: []types.Type{\n")
	//for _, typ := range idl.Types {
	//	sb.WriteString(fmt.Sprintf("        {Name: %q, Type: TypeField{Kind: %q, Fields: []Field{\n", typ.Name, typ.Type.Kind))
	//	for _, field := range typ.Type.Fields {
	//		sb.WriteString(fmt.Sprintf("            {Name: %q, Type: %v},\n", field.Name, field.Type))
	//	}
	//	sb.WriteString("        }}},\n")
	//}
	//sb.WriteString("    },\n")

	sb.WriteString("}\n")
	return sb.String()
}

// generateDiscriminatorCode generates the Go code for a discriminator.
// use format [8]byte{...}
func generateDiscriminatorCode(discriminator [8]byte) string {
	var sb strings.Builder

	sb.WriteString("[8]byte{")
	for i, b := range discriminator {
		sb.WriteString(fmt.Sprintf("%d", b))
		if i < len(discriminator)-1 {
			sb.WriteString(", ")
		}
	}
	sb.WriteString("}")

	return sb.String()
}

// generateAccountCode generates the Go code for an Account struct.
func generateAccountCode(acc types.Account) string {
	var sb strings.Builder

	sb.WriteString("                {\n")
	sb.WriteString(fmt.Sprintf("                    Name: %q,\n", acc.Name))
	sb.WriteString(fmt.Sprintf("                    Writable: %t,\n", acc.Writable))
	sb.WriteString(fmt.Sprintf("                    Signer: %t,\n", acc.Signer))
	sb.WriteString(fmt.Sprintf("                    Address: %q,\n", acc.Address))

	// TODO: PDA generation
	//if acc.PDA != nil {
	//	sb.WriteString("                    PDA: &types.PDA{\n")
	//	sb.WriteString("                        Seeds: []types.Seed{\n")
	//	for _, seed := range acc.PDA.Seeds {
	//		sb.WriteString(fmt.Sprintf("                            {Kind: %q, Value: %v},\n", seed.Kind, seed.Value))
	//	}
	//	sb.WriteString("                        },\n")
	//	sb.WriteString("                    },\n")
	//} else {
	//	sb.WriteString("                    PDA: nil,\n")
	//}

	sb.WriteString("                    PDA: nil,\n")

	sb.WriteString("                },\n")
	return sb.String()
}

// generateInstructionNames generates Go constants for a list of instruction names.
func generateInstructionNames(idl *types.IDL) string {
	var builder strings.Builder

	instructions := make([]string, 0, len(idl.Instructions))
	for _, instr := range idl.Instructions {
		instructions = append(instructions, instr.Name)
	}

	// Begin the const block.
	builder.WriteString("const (\n")

	// Iterate over the instructions and add each one as a constant.
	for _, instruction := range instructions {
		capitalizedName := capitalize(instruction)

		// Write the constant definition.
		builder.WriteString(fmt.Sprintf("    %s%s = \"%s\"\n", instructionNamePrefix, capitalizedName, instruction))
	}

	// End the const block.
	builder.WriteString(")\n")

	// Return the generated string.
	return builder.String()
}

// capitalize returns the string with the first letter in uppercase.
func capitalize(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}
